{"ast":null,"code":"/**\n * Execution State Management Utility\n *\n * This utility provides functions to manage and update workflow execution state.\n * In a production environment, this would integrate with WebSocket connections\n * to receive real-time updates from the backend Gradio application.\n */\n\n// Execution state constants\nexport const ExecutionState = {\n  IDLE: 'idle',\n  RUNNING: 'running',\n  COMPLETED: 'completed',\n  FAILED: 'failed'\n};\n\n/**\n * Executes a workflow using the real Gradio backend API.\n *\n * @param {Array} nodes - Array of workflow nodes\n * @param {Function} updateNodeState - Callback to update node state\n * @param {string} apiBaseUrl - Base URL for API (default: http://localhost:7860)\n * @returns {Promise} Promise that resolves when execution completes\n */\nexport const executeWorkflow = async (nodes, updateNodeState, apiBaseUrl = 'http://localhost:7860') => {\n  // Reset all nodes to idle state\n  nodes.forEach(node => {\n    updateNodeState(node.id, ExecutionState.IDLE);\n  });\n  try {\n    // Extract agent IDs from nodes\n    const agents = nodes.map(node => node.data.label);\n\n    // Start execution\n    const response = await fetch(`${apiBaseUrl}/api/execute-team`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        agents: agents,\n        prompt: \"Execute workflow\"\n      })\n    });\n    if (!response.ok) throw new Error('Failed to start execution');\n    const {\n      executionId\n    } = await response.json();\n\n    // Poll for status updates\n    let attempts = 0;\n    const maxAttempts = 120; // 2 minutes\n\n    while (attempts < maxAttempts) {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      const statusResponse = await fetch(`${apiBaseUrl}/api/status/${executionId}`);\n      const status = await statusResponse.json();\n\n      // Update node states based on progress\n      if (status.outputs) {\n        status.outputs.forEach(output => {\n          const node = nodes.find(n => n.data.label === output.agentId);\n          if (node) {\n            updateNodeState(node.id, ExecutionState.COMPLETED);\n          }\n        });\n      }\n\n      // Mark currently running agent\n      if (status.status === 'running' && status.progress) {\n        const currentIndex = Math.floor(status.progress / 100 * agents.length);\n        if (currentIndex < agents.length) {\n          const node = nodes[currentIndex];\n          updateNodeState(node.id, ExecutionState.RUNNING);\n        }\n      }\n      if (status.status === 'completed') {\n        console.log('Workflow execution complete');\n        return {\n          success: true,\n          outputs: status.outputs\n        };\n      } else if (status.status === 'failed') {\n        console.error('Workflow execution failed:', status.error);\n        // Mark failed node\n        const lastNode = nodes[Math.floor(status.progress / 100 * agents.length)];\n        if (lastNode) {\n          updateNodeState(lastNode.id, ExecutionState.FAILED);\n        }\n        return {\n          success: false,\n          error: status.error\n        };\n      }\n      attempts++;\n    }\n    throw new Error('Execution timeout');\n  } catch (error) {\n    console.error('Execution failed:', error);\n    throw error;\n  }\n};\n\n/**\n * Simulates workflow execution for demonstration purposes (LEGACY).\n * Use executeWorkflow() for real backend integration.\n *\n * @param {Array} nodes - Array of workflow nodes\n * @param {Function} updateNodeState - Callback to update node state\n * @param {number} delayPerAgent - Delay in milliseconds between agents (default: 3000)\n */\nexport const simulateWorkflowExecution = async (nodes, updateNodeState, delayPerAgent = 3000) => {\n  console.warn('simulateWorkflowExecution is deprecated. Use executeWorkflow() instead.');\n\n  // Reset all nodes to idle state\n  nodes.forEach(node => {\n    updateNodeState(node.id, ExecutionState.IDLE);\n  });\n\n  // Execute nodes sequentially\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // Set current node to running\n    updateNodeState(node.id, ExecutionState.RUNNING);\n\n    // Simulate execution time\n    await new Promise(resolve => setTimeout(resolve, delayPerAgent));\n\n    // Set to completed (randomly fail ~10% of the time for demo)\n    const success = Math.random() > 0.1;\n    updateNodeState(node.id, success ? ExecutionState.COMPLETED : ExecutionState.FAILED);\n\n    // If failed, stop execution\n    if (!success) {\n      console.log(`Agent ${node.data.label} failed, stopping execution`);\n      break;\n    }\n  }\n  console.log('Workflow execution complete');\n};\n\n/**\n * Connects to a WebSocket server for real-time execution updates.\n * This would be used in production to receive updates from the Gradio backend.\n *\n * @param {string} websocketUrl - WebSocket server URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @returns {WebSocket} WebSocket instance\n */\nexport const connectToExecutionStream = (websocketUrl, onStateUpdate) => {\n  const ws = new WebSocket(websocketUrl);\n  ws.onopen = () => {\n    console.log('Connected to execution stream');\n  };\n  ws.onmessage = event => {\n    try {\n      const data = JSON.parse(event.data);\n\n      // Expected message format:\n      // {\n      //   type: 'execution_update',\n      //   agentId: 'PM',\n      //   state: 'running' | 'completed' | 'failed',\n      //   timestamp: '2024-01-10T12:00:00Z'\n      // }\n\n      if (data.type === 'execution_update') {\n        onStateUpdate(data.agentId, data.state);\n      }\n    } catch (error) {\n      console.error('Error parsing execution update:', error);\n    }\n  };\n  ws.onerror = error => {\n    console.error('WebSocket error:', error);\n  };\n  ws.onclose = () => {\n    console.log('Disconnected from execution stream');\n  };\n  return ws;\n};\n\n/**\n * HTTP polling alternative for execution state updates.\n * Polls an API endpoint for execution status.\n *\n * @param {string} apiUrl - API endpoint URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @param {number} pollInterval - Poll interval in milliseconds (default: 1000)\n * @returns {Function} Cleanup function to stop polling\n */\nexport const pollExecutionState = (apiUrl, onStateUpdate, pollInterval = 1000) => {\n  let isPolling = true;\n  const poll = async () => {\n    while (isPolling) {\n      try {\n        const response = await fetch(apiUrl);\n        const data = await response.json();\n\n        // Expected response format:\n        // {\n        //   agentStates: {\n        //     'PM': 'completed',\n        //     'Research': 'running',\n        //     'Ideas': 'idle'\n        //   }\n        // }\n\n        if (data.agentStates) {\n          Object.entries(data.agentStates).forEach(([agentId, state]) => {\n            onStateUpdate(agentId, state);\n          });\n        }\n      } catch (error) {\n        console.error('Error polling execution state:', error);\n      }\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\n    }\n  };\n  poll();\n\n  // Return cleanup function\n  return () => {\n    isPolling = false;\n  };\n};","map":{"version":3,"names":["ExecutionState","IDLE","RUNNING","COMPLETED","FAILED","executeWorkflow","nodes","updateNodeState","apiBaseUrl","forEach","node","id","agents","map","data","label","response","fetch","method","headers","body","JSON","stringify","prompt","ok","Error","executionId","json","attempts","maxAttempts","Promise","resolve","setTimeout","statusResponse","status","outputs","output","find","n","agentId","progress","currentIndex","Math","floor","length","console","log","success","error","lastNode","simulateWorkflowExecution","delayPerAgent","warn","i","random","connectToExecutionStream","websocketUrl","onStateUpdate","ws","WebSocket","onopen","onmessage","event","parse","type","state","onerror","onclose","pollExecutionState","apiUrl","pollInterval","isPolling","poll","agentStates","Object","entries"],"sources":["C:/Users/jacob/MultiAgentTeam/workflow_builder/src/utils/executionState.js"],"sourcesContent":["/**\n * Execution State Management Utility\n *\n * This utility provides functions to manage and update workflow execution state.\n * In a production environment, this would integrate with WebSocket connections\n * to receive real-time updates from the backend Gradio application.\n */\n\n// Execution state constants\nexport const ExecutionState = {\n  IDLE: 'idle',\n  RUNNING: 'running',\n  COMPLETED: 'completed',\n  FAILED: 'failed',\n};\n\n/**\n * Executes a workflow using the real Gradio backend API.\n *\n * @param {Array} nodes - Array of workflow nodes\n * @param {Function} updateNodeState - Callback to update node state\n * @param {string} apiBaseUrl - Base URL for API (default: http://localhost:7860)\n * @returns {Promise} Promise that resolves when execution completes\n */\nexport const executeWorkflow = async (nodes, updateNodeState, apiBaseUrl = 'http://localhost:7860') => {\n  // Reset all nodes to idle state\n  nodes.forEach(node => {\n    updateNodeState(node.id, ExecutionState.IDLE);\n  });\n\n  try {\n    // Extract agent IDs from nodes\n    const agents = nodes.map(node => node.data.label);\n\n    // Start execution\n    const response = await fetch(`${apiBaseUrl}/api/execute-team`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        agents: agents,\n        prompt: \"Execute workflow\"\n      })\n    });\n\n    if (!response.ok) throw new Error('Failed to start execution');\n\n    const { executionId } = await response.json();\n\n    // Poll for status updates\n    let attempts = 0;\n    const maxAttempts = 120;  // 2 minutes\n\n    while (attempts < maxAttempts) {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      const statusResponse = await fetch(`${apiBaseUrl}/api/status/${executionId}`);\n      const status = await statusResponse.json();\n\n      // Update node states based on progress\n      if (status.outputs) {\n        status.outputs.forEach(output => {\n          const node = nodes.find(n => n.data.label === output.agentId);\n          if (node) {\n            updateNodeState(node.id, ExecutionState.COMPLETED);\n          }\n        });\n      }\n\n      // Mark currently running agent\n      if (status.status === 'running' && status.progress) {\n        const currentIndex = Math.floor((status.progress / 100) * agents.length);\n        if (currentIndex < agents.length) {\n          const node = nodes[currentIndex];\n          updateNodeState(node.id, ExecutionState.RUNNING);\n        }\n      }\n\n      if (status.status === 'completed') {\n        console.log('Workflow execution complete');\n        return { success: true, outputs: status.outputs };\n      } else if (status.status === 'failed') {\n        console.error('Workflow execution failed:', status.error);\n        // Mark failed node\n        const lastNode = nodes[Math.floor((status.progress / 100) * agents.length)];\n        if (lastNode) {\n          updateNodeState(lastNode.id, ExecutionState.FAILED);\n        }\n        return { success: false, error: status.error };\n      }\n\n      attempts++;\n    }\n\n    throw new Error('Execution timeout');\n\n  } catch (error) {\n    console.error('Execution failed:', error);\n    throw error;\n  }\n};\n\n/**\n * Simulates workflow execution for demonstration purposes (LEGACY).\n * Use executeWorkflow() for real backend integration.\n *\n * @param {Array} nodes - Array of workflow nodes\n * @param {Function} updateNodeState - Callback to update node state\n * @param {number} delayPerAgent - Delay in milliseconds between agents (default: 3000)\n */\nexport const simulateWorkflowExecution = async (nodes, updateNodeState, delayPerAgent = 3000) => {\n  console.warn('simulateWorkflowExecution is deprecated. Use executeWorkflow() instead.');\n\n  // Reset all nodes to idle state\n  nodes.forEach(node => {\n    updateNodeState(node.id, ExecutionState.IDLE);\n  });\n\n  // Execute nodes sequentially\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // Set current node to running\n    updateNodeState(node.id, ExecutionState.RUNNING);\n\n    // Simulate execution time\n    await new Promise(resolve => setTimeout(resolve, delayPerAgent));\n\n    // Set to completed (randomly fail ~10% of the time for demo)\n    const success = Math.random() > 0.1;\n    updateNodeState(node.id, success ? ExecutionState.COMPLETED : ExecutionState.FAILED);\n\n    // If failed, stop execution\n    if (!success) {\n      console.log(`Agent ${node.data.label} failed, stopping execution`);\n      break;\n    }\n  }\n\n  console.log('Workflow execution complete');\n};\n\n/**\n * Connects to a WebSocket server for real-time execution updates.\n * This would be used in production to receive updates from the Gradio backend.\n *\n * @param {string} websocketUrl - WebSocket server URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @returns {WebSocket} WebSocket instance\n */\nexport const connectToExecutionStream = (websocketUrl, onStateUpdate) => {\n  const ws = new WebSocket(websocketUrl);\n\n  ws.onopen = () => {\n    console.log('Connected to execution stream');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n\n      // Expected message format:\n      // {\n      //   type: 'execution_update',\n      //   agentId: 'PM',\n      //   state: 'running' | 'completed' | 'failed',\n      //   timestamp: '2024-01-10T12:00:00Z'\n      // }\n\n      if (data.type === 'execution_update') {\n        onStateUpdate(data.agentId, data.state);\n      }\n    } catch (error) {\n      console.error('Error parsing execution update:', error);\n    }\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('Disconnected from execution stream');\n  };\n\n  return ws;\n};\n\n/**\n * HTTP polling alternative for execution state updates.\n * Polls an API endpoint for execution status.\n *\n * @param {string} apiUrl - API endpoint URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @param {number} pollInterval - Poll interval in milliseconds (default: 1000)\n * @returns {Function} Cleanup function to stop polling\n */\nexport const pollExecutionState = (apiUrl, onStateUpdate, pollInterval = 1000) => {\n  let isPolling = true;\n\n  const poll = async () => {\n    while (isPolling) {\n      try {\n        const response = await fetch(apiUrl);\n        const data = await response.json();\n\n        // Expected response format:\n        // {\n        //   agentStates: {\n        //     'PM': 'completed',\n        //     'Research': 'running',\n        //     'Ideas': 'idle'\n        //   }\n        // }\n\n        if (data.agentStates) {\n          Object.entries(data.agentStates).forEach(([agentId, state]) => {\n            onStateUpdate(agentId, state);\n          });\n        }\n      } catch (error) {\n        console.error('Error polling execution state:', error);\n      }\n\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\n    }\n  };\n\n  poll();\n\n  // Return cleanup function\n  return () => {\n    isPolling = false;\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}