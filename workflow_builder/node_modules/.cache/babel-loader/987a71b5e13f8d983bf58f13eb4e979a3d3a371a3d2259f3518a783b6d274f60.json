{"ast":null,"code":"/**\n * Workflow Validation Utility\n *\n * Validates workflow structure and provides error/warning feedback\n * Checks for: circular dependencies, disconnected nodes, missing fields, etc.\n */\n\n/**\n * Validation error types\n */\nexport const ValidationErrorType = {\n  CIRCULAR_DEPENDENCY: 'circular_dependency',\n  DISCONNECTED_NODE: 'disconnected_node',\n  MISSING_AGENT_TYPE: 'missing_agent_type',\n  EMPTY_WORKFLOW: 'empty_workflow',\n  DUPLICATE_CONNECTION: 'duplicate_connection',\n  INVALID_CONNECTION: 'invalid_connection'\n};\n\n/**\n * Validation severity levels\n */\nexport const ValidationSeverity = {\n  ERROR: 'error',\n  // Blocks workflow execution\n  WARNING: 'warning',\n  // Doesn't block but suggests improvement\n  INFO: 'info' // Informational message\n};\n\n/**\n * Main validation function\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Object} Validation result with errors and warnings\n */\nexport const validateWorkflow = (nodes, edges) => {\n  const errors = [];\n  const warnings = [];\n  const info = [];\n\n  // 1. Check if workflow is empty\n  if (!nodes || nodes.length === 0) {\n    errors.push({\n      type: ValidationErrorType.EMPTY_WORKFLOW,\n      severity: ValidationSeverity.ERROR,\n      message: 'Workflow is empty. Add at least one agent to get started.',\n      nodeIds: []\n    });\n    return {\n      valid: false,\n      errors,\n      warnings,\n      info\n    };\n  }\n\n  // 2. Check for circular dependencies\n  const circularDeps = detectCircularDependencies(nodes, edges);\n  if (circularDeps.length > 0) {\n    circularDeps.forEach(cycle => {\n      errors.push({\n        type: ValidationErrorType.CIRCULAR_DEPENDENCY,\n        severity: ValidationSeverity.ERROR,\n        message: `Circular dependency detected: ${cycle.join(' → ')}`,\n        nodeIds: cycle,\n        details: 'Agents cannot depend on each other in a circular way. This would cause an infinite loop.'\n      });\n    });\n  }\n\n  // 3. Check for disconnected nodes (warnings, not errors)\n  const disconnectedNodes = detectDisconnectedNodes(nodes, edges);\n  if (disconnectedNodes.length > 0) {\n    disconnectedNodes.forEach(nodeId => {\n      var _node$data;\n      const node = nodes.find(n => n.id === nodeId);\n      warnings.push({\n        type: ValidationErrorType.DISCONNECTED_NODE,\n        severity: ValidationSeverity.WARNING,\n        message: `Agent \"${(node === null || node === void 0 ? void 0 : (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.label) || nodeId}\" has no connections`,\n        nodeIds: [nodeId],\n        details: 'This agent will run independently without receiving input from or sending output to other agents.'\n      });\n    });\n  }\n\n  // 4. Check for missing agent types\n  nodes.forEach(node => {\n    var _node$data2;\n    if (!((_node$data2 = node.data) !== null && _node$data2 !== void 0 && _node$data2.agentType) || node.data.agentType.trim() === '') {\n      errors.push({\n        type: ValidationErrorType.MISSING_AGENT_TYPE,\n        severity: ValidationSeverity.ERROR,\n        message: `Node \"${node.id}\" is missing an agent type`,\n        nodeIds: [node.id],\n        details: 'Every agent must have a valid agent type assigned.'\n      });\n    }\n  });\n\n  // 5. Check for duplicate connections\n  const duplicateEdges = detectDuplicateConnections(edges);\n  if (duplicateEdges.length > 0) {\n    duplicateEdges.forEach(edge => {\n      warnings.push({\n        type: ValidationErrorType.DUPLICATE_CONNECTION,\n        severity: ValidationSeverity.WARNING,\n        message: `Duplicate connection detected between agents`,\n        nodeIds: [edge.source, edge.target],\n        edgeId: edge.id,\n        details: 'Multiple connections between the same agents are redundant.'\n      });\n    });\n  }\n\n  // 6. Informational: workflow stats\n  const stats = calculateWorkflowStats(nodes, edges);\n  info.push({\n    severity: ValidationSeverity.INFO,\n    message: `Workflow contains ${stats.nodeCount} agent(s) and ${stats.edgeCount} connection(s)`,\n    details: stats\n  });\n\n  // Determine overall validity\n  const valid = errors.length === 0;\n  return {\n    valid,\n    errors,\n    warnings,\n    info,\n    stats\n  };\n};\n\n/**\n * Detect circular dependencies using DFS\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Array} Array of cycles (each cycle is an array of node IDs)\n */\nconst detectCircularDependencies = (nodes, edges) => {\n  const cycles = [];\n  const visited = new Set();\n  const recursionStack = new Set();\n  const nodeMap = new Map(nodes.map(n => [n.id, n]));\n\n  // Build adjacency list\n  const adjacencyList = new Map();\n  nodes.forEach(node => {\n    adjacencyList.set(node.id, []);\n  });\n  edges.forEach(edge => {\n    if (adjacencyList.has(edge.source)) {\n      adjacencyList.get(edge.source).push(edge.target);\n    }\n  });\n\n  // DFS to detect cycles\n  const dfs = (nodeId, path = []) => {\n    visited.add(nodeId);\n    recursionStack.add(nodeId);\n    path.push(nodeId);\n    const neighbors = adjacencyList.get(nodeId) || [];\n    for (const neighbor of neighbors) {\n      if (!visited.has(neighbor)) {\n        if (dfs(neighbor, [...path])) {\n          return true;\n        }\n      } else if (recursionStack.has(neighbor)) {\n        // Found a cycle\n        const cycleStart = path.indexOf(neighbor);\n        const cycle = path.slice(cycleStart).map(id => {\n          var _node$data3;\n          const node = nodeMap.get(id);\n          return (node === null || node === void 0 ? void 0 : (_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.label) || id;\n        });\n        cycle.push(cycle[0]); // Complete the cycle\n        cycles.push(cycle);\n        return true;\n      }\n    }\n    recursionStack.delete(nodeId);\n    return false;\n  };\n\n  // Check all nodes\n  nodes.forEach(node => {\n    if (!visited.has(node.id)) {\n      dfs(node.id);\n    }\n  });\n  return cycles;\n};\n\n/**\n * Detect disconnected nodes (nodes with no incoming or outgoing edges)\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Array} Array of disconnected node IDs\n */\nconst detectDisconnectedNodes = (nodes, edges) => {\n  const connectedNodes = new Set();\n  edges.forEach(edge => {\n    connectedNodes.add(edge.source);\n    connectedNodes.add(edge.target);\n  });\n  const disconnected = nodes.filter(node => !connectedNodes.has(node.id)).map(node => node.id);\n  return disconnected;\n};\n\n/**\n * Detect duplicate connections (same source and target)\n *\n * @param {Array} edges - React Flow edges\n * @returns {Array} Array of duplicate edges\n */\nconst detectDuplicateConnections = edges => {\n  const seen = new Set();\n  const duplicates = [];\n  edges.forEach(edge => {\n    const key = `${edge.source}->${edge.target}`;\n    if (seen.has(key)) {\n      duplicates.push(edge);\n    } else {\n      seen.add(key);\n    }\n  });\n  return duplicates;\n};\n\n/**\n * Calculate workflow statistics\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Object} Workflow statistics\n */\nconst calculateWorkflowStats = (nodes, edges) => {\n  const agentTypes = nodes.map(n => {\n    var _n$data;\n    return (_n$data = n.data) === null || _n$data === void 0 ? void 0 : _n$data.agentType;\n  }).filter(Boolean);\n  const uniqueAgentTypes = new Set(agentTypes);\n  const customAgents = nodes.filter(n => {\n    var _n$data2;\n    return (_n$data2 = n.data) === null || _n$data2 === void 0 ? void 0 : _n$data2.custom;\n  }).length;\n  const builtinAgents = nodes.length - customAgents;\n  return {\n    nodeCount: nodes.length,\n    edgeCount: edges.length,\n    uniqueAgentTypes: uniqueAgentTypes.size,\n    customAgentsCount: customAgents,\n    builtinAgentsCount: builtinAgents,\n    averageConnectionsPerNode: nodes.length > 0 ? (edges.length / nodes.length).toFixed(2) : 0\n  };\n};\n\n/**\n * Get validation summary message\n *\n * @param {Object} validationResult - Result from validateWorkflow\n * @returns {String} Human-readable summary\n */\nexport const getValidationSummary = validationResult => {\n  const {\n    valid,\n    errors,\n    warnings\n  } = validationResult;\n  if (valid && warnings.length === 0) {\n    return '✅ Workflow is valid with no issues';\n  } else if (valid && warnings.length > 0) {\n    return `✅ Workflow is valid but has ${warnings.length} warning(s)`;\n  } else {\n    return `❌ Workflow has ${errors.length} error(s) and ${warnings.length} warning(s)`;\n  }\n};\n\n/**\n * Filter validation results by severity\n *\n * @param {Object} validationResult - Result from validateWorkflow\n * @param {String} severity - Severity level to filter by\n * @returns {Array} Filtered validation messages\n */\nexport const filterBySeverity = (validationResult, severity) => {\n  const {\n    errors,\n    warnings,\n    info\n  } = validationResult;\n  switch (severity) {\n    case ValidationSeverity.ERROR:\n      return errors;\n    case ValidationSeverity.WARNING:\n      return warnings;\n    case ValidationSeverity.INFO:\n      return info;\n    default:\n      return [...errors, ...warnings, ...info];\n  }\n};","map":{"version":3,"names":["ValidationErrorType","CIRCULAR_DEPENDENCY","DISCONNECTED_NODE","MISSING_AGENT_TYPE","EMPTY_WORKFLOW","DUPLICATE_CONNECTION","INVALID_CONNECTION","ValidationSeverity","ERROR","WARNING","INFO","validateWorkflow","nodes","edges","errors","warnings","info","length","push","type","severity","message","nodeIds","valid","circularDeps","detectCircularDependencies","forEach","cycle","join","details","disconnectedNodes","detectDisconnectedNodes","nodeId","_node$data","node","find","n","id","data","label","_node$data2","agentType","trim","duplicateEdges","detectDuplicateConnections","edge","source","target","edgeId","stats","calculateWorkflowStats","nodeCount","edgeCount","cycles","visited","Set","recursionStack","nodeMap","Map","map","adjacencyList","set","has","get","dfs","path","add","neighbors","neighbor","cycleStart","indexOf","slice","_node$data3","delete","connectedNodes","disconnected","filter","seen","duplicates","key","agentTypes","_n$data","Boolean","uniqueAgentTypes","customAgents","_n$data2","custom","builtinAgents","size","customAgentsCount","builtinAgentsCount","averageConnectionsPerNode","toFixed","getValidationSummary","validationResult","filterBySeverity"],"sources":["C:/Users/jacob/MultiAgentTeam/workflow_builder/src/utils/workflowValidator.js"],"sourcesContent":["/**\n * Workflow Validation Utility\n *\n * Validates workflow structure and provides error/warning feedback\n * Checks for: circular dependencies, disconnected nodes, missing fields, etc.\n */\n\n/**\n * Validation error types\n */\nexport const ValidationErrorType = {\n  CIRCULAR_DEPENDENCY: 'circular_dependency',\n  DISCONNECTED_NODE: 'disconnected_node',\n  MISSING_AGENT_TYPE: 'missing_agent_type',\n  EMPTY_WORKFLOW: 'empty_workflow',\n  DUPLICATE_CONNECTION: 'duplicate_connection',\n  INVALID_CONNECTION: 'invalid_connection',\n};\n\n/**\n * Validation severity levels\n */\nexport const ValidationSeverity = {\n  ERROR: 'error',      // Blocks workflow execution\n  WARNING: 'warning',  // Doesn't block but suggests improvement\n  INFO: 'info',        // Informational message\n};\n\n/**\n * Main validation function\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Object} Validation result with errors and warnings\n */\nexport const validateWorkflow = (nodes, edges) => {\n  const errors = [];\n  const warnings = [];\n  const info = [];\n\n  // 1. Check if workflow is empty\n  if (!nodes || nodes.length === 0) {\n    errors.push({\n      type: ValidationErrorType.EMPTY_WORKFLOW,\n      severity: ValidationSeverity.ERROR,\n      message: 'Workflow is empty. Add at least one agent to get started.',\n      nodeIds: [],\n    });\n    return { valid: false, errors, warnings, info };\n  }\n\n  // 2. Check for circular dependencies\n  const circularDeps = detectCircularDependencies(nodes, edges);\n  if (circularDeps.length > 0) {\n    circularDeps.forEach(cycle => {\n      errors.push({\n        type: ValidationErrorType.CIRCULAR_DEPENDENCY,\n        severity: ValidationSeverity.ERROR,\n        message: `Circular dependency detected: ${cycle.join(' → ')}`,\n        nodeIds: cycle,\n        details: 'Agents cannot depend on each other in a circular way. This would cause an infinite loop.',\n      });\n    });\n  }\n\n  // 3. Check for disconnected nodes (warnings, not errors)\n  const disconnectedNodes = detectDisconnectedNodes(nodes, edges);\n  if (disconnectedNodes.length > 0) {\n    disconnectedNodes.forEach(nodeId => {\n      const node = nodes.find(n => n.id === nodeId);\n      warnings.push({\n        type: ValidationErrorType.DISCONNECTED_NODE,\n        severity: ValidationSeverity.WARNING,\n        message: `Agent \"${node?.data?.label || nodeId}\" has no connections`,\n        nodeIds: [nodeId],\n        details: 'This agent will run independently without receiving input from or sending output to other agents.',\n      });\n    });\n  }\n\n  // 4. Check for missing agent types\n  nodes.forEach(node => {\n    if (!node.data?.agentType || node.data.agentType.trim() === '') {\n      errors.push({\n        type: ValidationErrorType.MISSING_AGENT_TYPE,\n        severity: ValidationSeverity.ERROR,\n        message: `Node \"${node.id}\" is missing an agent type`,\n        nodeIds: [node.id],\n        details: 'Every agent must have a valid agent type assigned.',\n      });\n    }\n  });\n\n  // 5. Check for duplicate connections\n  const duplicateEdges = detectDuplicateConnections(edges);\n  if (duplicateEdges.length > 0) {\n    duplicateEdges.forEach(edge => {\n      warnings.push({\n        type: ValidationErrorType.DUPLICATE_CONNECTION,\n        severity: ValidationSeverity.WARNING,\n        message: `Duplicate connection detected between agents`,\n        nodeIds: [edge.source, edge.target],\n        edgeId: edge.id,\n        details: 'Multiple connections between the same agents are redundant.',\n      });\n    });\n  }\n\n  // 6. Informational: workflow stats\n  const stats = calculateWorkflowStats(nodes, edges);\n  info.push({\n    severity: ValidationSeverity.INFO,\n    message: `Workflow contains ${stats.nodeCount} agent(s) and ${stats.edgeCount} connection(s)`,\n    details: stats,\n  });\n\n  // Determine overall validity\n  const valid = errors.length === 0;\n\n  return {\n    valid,\n    errors,\n    warnings,\n    info,\n    stats,\n  };\n};\n\n/**\n * Detect circular dependencies using DFS\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Array} Array of cycles (each cycle is an array of node IDs)\n */\nconst detectCircularDependencies = (nodes, edges) => {\n  const cycles = [];\n  const visited = new Set();\n  const recursionStack = new Set();\n  const nodeMap = new Map(nodes.map(n => [n.id, n]));\n\n  // Build adjacency list\n  const adjacencyList = new Map();\n  nodes.forEach(node => {\n    adjacencyList.set(node.id, []);\n  });\n  edges.forEach(edge => {\n    if (adjacencyList.has(edge.source)) {\n      adjacencyList.get(edge.source).push(edge.target);\n    }\n  });\n\n  // DFS to detect cycles\n  const dfs = (nodeId, path = []) => {\n    visited.add(nodeId);\n    recursionStack.add(nodeId);\n    path.push(nodeId);\n\n    const neighbors = adjacencyList.get(nodeId) || [];\n    for (const neighbor of neighbors) {\n      if (!visited.has(neighbor)) {\n        if (dfs(neighbor, [...path])) {\n          return true;\n        }\n      } else if (recursionStack.has(neighbor)) {\n        // Found a cycle\n        const cycleStart = path.indexOf(neighbor);\n        const cycle = path.slice(cycleStart).map(id => {\n          const node = nodeMap.get(id);\n          return node?.data?.label || id;\n        });\n        cycle.push(cycle[0]); // Complete the cycle\n        cycles.push(cycle);\n        return true;\n      }\n    }\n\n    recursionStack.delete(nodeId);\n    return false;\n  };\n\n  // Check all nodes\n  nodes.forEach(node => {\n    if (!visited.has(node.id)) {\n      dfs(node.id);\n    }\n  });\n\n  return cycles;\n};\n\n/**\n * Detect disconnected nodes (nodes with no incoming or outgoing edges)\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Array} Array of disconnected node IDs\n */\nconst detectDisconnectedNodes = (nodes, edges) => {\n  const connectedNodes = new Set();\n\n  edges.forEach(edge => {\n    connectedNodes.add(edge.source);\n    connectedNodes.add(edge.target);\n  });\n\n  const disconnected = nodes\n    .filter(node => !connectedNodes.has(node.id))\n    .map(node => node.id);\n\n  return disconnected;\n};\n\n/**\n * Detect duplicate connections (same source and target)\n *\n * @param {Array} edges - React Flow edges\n * @returns {Array} Array of duplicate edges\n */\nconst detectDuplicateConnections = (edges) => {\n  const seen = new Set();\n  const duplicates = [];\n\n  edges.forEach(edge => {\n    const key = `${edge.source}->${edge.target}`;\n    if (seen.has(key)) {\n      duplicates.push(edge);\n    } else {\n      seen.add(key);\n    }\n  });\n\n  return duplicates;\n};\n\n/**\n * Calculate workflow statistics\n *\n * @param {Array} nodes - React Flow nodes\n * @param {Array} edges - React Flow edges\n * @returns {Object} Workflow statistics\n */\nconst calculateWorkflowStats = (nodes, edges) => {\n  const agentTypes = nodes.map(n => n.data?.agentType).filter(Boolean);\n  const uniqueAgentTypes = new Set(agentTypes);\n\n  const customAgents = nodes.filter(n => n.data?.custom).length;\n  const builtinAgents = nodes.length - customAgents;\n\n  return {\n    nodeCount: nodes.length,\n    edgeCount: edges.length,\n    uniqueAgentTypes: uniqueAgentTypes.size,\n    customAgentsCount: customAgents,\n    builtinAgentsCount: builtinAgents,\n    averageConnectionsPerNode: nodes.length > 0 ? (edges.length / nodes.length).toFixed(2) : 0,\n  };\n};\n\n/**\n * Get validation summary message\n *\n * @param {Object} validationResult - Result from validateWorkflow\n * @returns {String} Human-readable summary\n */\nexport const getValidationSummary = (validationResult) => {\n  const { valid, errors, warnings } = validationResult;\n\n  if (valid && warnings.length === 0) {\n    return '✅ Workflow is valid with no issues';\n  } else if (valid && warnings.length > 0) {\n    return `✅ Workflow is valid but has ${warnings.length} warning(s)`;\n  } else {\n    return `❌ Workflow has ${errors.length} error(s) and ${warnings.length} warning(s)`;\n  }\n};\n\n/**\n * Filter validation results by severity\n *\n * @param {Object} validationResult - Result from validateWorkflow\n * @param {String} severity - Severity level to filter by\n * @returns {Array} Filtered validation messages\n */\nexport const filterBySeverity = (validationResult, severity) => {\n  const { errors, warnings, info } = validationResult;\n\n  switch (severity) {\n    case ValidationSeverity.ERROR:\n      return errors;\n    case ValidationSeverity.WARNING:\n      return warnings;\n    case ValidationSeverity.INFO:\n      return info;\n    default:\n      return [...errors, ...warnings, ...info];\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,MAAMA,mBAAmB,GAAG;EACjCC,mBAAmB,EAAE,qBAAqB;EAC1CC,iBAAiB,EAAE,mBAAmB;EACtCC,kBAAkB,EAAE,oBAAoB;EACxCC,cAAc,EAAE,gBAAgB;EAChCC,oBAAoB,EAAE,sBAAsB;EAC5CC,kBAAkB,EAAE;AACtB,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAG;EAChCC,KAAK,EAAE,OAAO;EAAO;EACrBC,OAAO,EAAE,SAAS;EAAG;EACrBC,IAAI,EAAE,MAAM,CAAS;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAAK;EAChD,MAAMC,MAAM,GAAG,EAAE;EACjB,MAAMC,QAAQ,GAAG,EAAE;EACnB,MAAMC,IAAI,GAAG,EAAE;;EAEf;EACA,IAAI,CAACJ,KAAK,IAAIA,KAAK,CAACK,MAAM,KAAK,CAAC,EAAE;IAChCH,MAAM,CAACI,IAAI,CAAC;MACVC,IAAI,EAAEnB,mBAAmB,CAACI,cAAc;MACxCgB,QAAQ,EAAEb,kBAAkB,CAACC,KAAK;MAClCa,OAAO,EAAE,2DAA2D;MACpEC,OAAO,EAAE;IACX,CAAC,CAAC;IACF,OAAO;MAAEC,KAAK,EAAE,KAAK;MAAET,MAAM;MAAEC,QAAQ;MAAEC;IAAK,CAAC;EACjD;;EAEA;EACA,MAAMQ,YAAY,GAAGC,0BAA0B,CAACb,KAAK,EAAEC,KAAK,CAAC;EAC7D,IAAIW,YAAY,CAACP,MAAM,GAAG,CAAC,EAAE;IAC3BO,YAAY,CAACE,OAAO,CAACC,KAAK,IAAI;MAC5Bb,MAAM,CAACI,IAAI,CAAC;QACVC,IAAI,EAAEnB,mBAAmB,CAACC,mBAAmB;QAC7CmB,QAAQ,EAAEb,kBAAkB,CAACC,KAAK;QAClCa,OAAO,EAAE,iCAAiCM,KAAK,CAACC,IAAI,CAAC,KAAK,CAAC,EAAE;QAC7DN,OAAO,EAAEK,KAAK;QACdE,OAAO,EAAE;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMC,iBAAiB,GAAGC,uBAAuB,CAACnB,KAAK,EAAEC,KAAK,CAAC;EAC/D,IAAIiB,iBAAiB,CAACb,MAAM,GAAG,CAAC,EAAE;IAChCa,iBAAiB,CAACJ,OAAO,CAACM,MAAM,IAAI;MAAA,IAAAC,UAAA;MAClC,MAAMC,IAAI,GAAGtB,KAAK,CAACuB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKL,MAAM,CAAC;MAC7CjB,QAAQ,CAACG,IAAI,CAAC;QACZC,IAAI,EAAEnB,mBAAmB,CAACE,iBAAiB;QAC3CkB,QAAQ,EAAEb,kBAAkB,CAACE,OAAO;QACpCY,OAAO,EAAE,UAAU,CAAAa,IAAI,aAAJA,IAAI,wBAAAD,UAAA,GAAJC,IAAI,CAAEI,IAAI,cAAAL,UAAA,uBAAVA,UAAA,CAAYM,KAAK,KAAIP,MAAM,sBAAsB;QACpEV,OAAO,EAAE,CAACU,MAAM,CAAC;QACjBH,OAAO,EAAE;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;EACAjB,KAAK,CAACc,OAAO,CAACQ,IAAI,IAAI;IAAA,IAAAM,WAAA;IACpB,IAAI,GAAAA,WAAA,GAACN,IAAI,CAACI,IAAI,cAAAE,WAAA,eAATA,WAAA,CAAWC,SAAS,KAAIP,IAAI,CAACI,IAAI,CAACG,SAAS,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MAC9D5B,MAAM,CAACI,IAAI,CAAC;QACVC,IAAI,EAAEnB,mBAAmB,CAACG,kBAAkB;QAC5CiB,QAAQ,EAAEb,kBAAkB,CAACC,KAAK;QAClCa,OAAO,EAAE,SAASa,IAAI,CAACG,EAAE,4BAA4B;QACrDf,OAAO,EAAE,CAACY,IAAI,CAACG,EAAE,CAAC;QAClBR,OAAO,EAAE;MACX,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;;EAEF;EACA,MAAMc,cAAc,GAAGC,0BAA0B,CAAC/B,KAAK,CAAC;EACxD,IAAI8B,cAAc,CAAC1B,MAAM,GAAG,CAAC,EAAE;IAC7B0B,cAAc,CAACjB,OAAO,CAACmB,IAAI,IAAI;MAC7B9B,QAAQ,CAACG,IAAI,CAAC;QACZC,IAAI,EAAEnB,mBAAmB,CAACK,oBAAoB;QAC9Ce,QAAQ,EAAEb,kBAAkB,CAACE,OAAO;QACpCY,OAAO,EAAE,8CAA8C;QACvDC,OAAO,EAAE,CAACuB,IAAI,CAACC,MAAM,EAAED,IAAI,CAACE,MAAM,CAAC;QACnCC,MAAM,EAAEH,IAAI,CAACR,EAAE;QACfR,OAAO,EAAE;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMoB,KAAK,GAAGC,sBAAsB,CAACtC,KAAK,EAAEC,KAAK,CAAC;EAClDG,IAAI,CAACE,IAAI,CAAC;IACRE,QAAQ,EAAEb,kBAAkB,CAACG,IAAI;IACjCW,OAAO,EAAE,qBAAqB4B,KAAK,CAACE,SAAS,iBAAiBF,KAAK,CAACG,SAAS,gBAAgB;IAC7FvB,OAAO,EAAEoB;EACX,CAAC,CAAC;;EAEF;EACA,MAAM1B,KAAK,GAAGT,MAAM,CAACG,MAAM,KAAK,CAAC;EAEjC,OAAO;IACLM,KAAK;IACLT,MAAM;IACNC,QAAQ;IACRC,IAAI;IACJiC;EACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMxB,0BAA0B,GAAGA,CAACb,KAAK,EAAEC,KAAK,KAAK;EACnD,MAAMwC,MAAM,GAAG,EAAE;EACjB,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,MAAMC,cAAc,GAAG,IAAID,GAAG,CAAC,CAAC;EAChC,MAAME,OAAO,GAAG,IAAIC,GAAG,CAAC9C,KAAK,CAAC+C,GAAG,CAACvB,CAAC,IAAI,CAACA,CAAC,CAACC,EAAE,EAAED,CAAC,CAAC,CAAC,CAAC;;EAElD;EACA,MAAMwB,aAAa,GAAG,IAAIF,GAAG,CAAC,CAAC;EAC/B9C,KAAK,CAACc,OAAO,CAACQ,IAAI,IAAI;IACpB0B,aAAa,CAACC,GAAG,CAAC3B,IAAI,CAACG,EAAE,EAAE,EAAE,CAAC;EAChC,CAAC,CAAC;EACFxB,KAAK,CAACa,OAAO,CAACmB,IAAI,IAAI;IACpB,IAAIe,aAAa,CAACE,GAAG,CAACjB,IAAI,CAACC,MAAM,CAAC,EAAE;MAClCc,aAAa,CAACG,GAAG,CAAClB,IAAI,CAACC,MAAM,CAAC,CAAC5B,IAAI,CAAC2B,IAAI,CAACE,MAAM,CAAC;IAClD;EACF,CAAC,CAAC;;EAEF;EACA,MAAMiB,GAAG,GAAGA,CAAChC,MAAM,EAAEiC,IAAI,GAAG,EAAE,KAAK;IACjCX,OAAO,CAACY,GAAG,CAAClC,MAAM,CAAC;IACnBwB,cAAc,CAACU,GAAG,CAAClC,MAAM,CAAC;IAC1BiC,IAAI,CAAC/C,IAAI,CAACc,MAAM,CAAC;IAEjB,MAAMmC,SAAS,GAAGP,aAAa,CAACG,GAAG,CAAC/B,MAAM,CAAC,IAAI,EAAE;IACjD,KAAK,MAAMoC,QAAQ,IAAID,SAAS,EAAE;MAChC,IAAI,CAACb,OAAO,CAACQ,GAAG,CAACM,QAAQ,CAAC,EAAE;QAC1B,IAAIJ,GAAG,CAACI,QAAQ,EAAE,CAAC,GAAGH,IAAI,CAAC,CAAC,EAAE;UAC5B,OAAO,IAAI;QACb;MACF,CAAC,MAAM,IAAIT,cAAc,CAACM,GAAG,CAACM,QAAQ,CAAC,EAAE;QACvC;QACA,MAAMC,UAAU,GAAGJ,IAAI,CAACK,OAAO,CAACF,QAAQ,CAAC;QACzC,MAAMzC,KAAK,GAAGsC,IAAI,CAACM,KAAK,CAACF,UAAU,CAAC,CAACV,GAAG,CAACtB,EAAE,IAAI;UAAA,IAAAmC,WAAA;UAC7C,MAAMtC,IAAI,GAAGuB,OAAO,CAACM,GAAG,CAAC1B,EAAE,CAAC;UAC5B,OAAO,CAAAH,IAAI,aAAJA,IAAI,wBAAAsC,WAAA,GAAJtC,IAAI,CAAEI,IAAI,cAAAkC,WAAA,uBAAVA,WAAA,CAAYjC,KAAK,KAAIF,EAAE;QAChC,CAAC,CAAC;QACFV,KAAK,CAACT,IAAI,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtB0B,MAAM,CAACnC,IAAI,CAACS,KAAK,CAAC;QAClB,OAAO,IAAI;MACb;IACF;IAEA6B,cAAc,CAACiB,MAAM,CAACzC,MAAM,CAAC;IAC7B,OAAO,KAAK;EACd,CAAC;;EAED;EACApB,KAAK,CAACc,OAAO,CAACQ,IAAI,IAAI;IACpB,IAAI,CAACoB,OAAO,CAACQ,GAAG,CAAC5B,IAAI,CAACG,EAAE,CAAC,EAAE;MACzB2B,GAAG,CAAC9B,IAAI,CAACG,EAAE,CAAC;IACd;EACF,CAAC,CAAC;EAEF,OAAOgB,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMtB,uBAAuB,GAAGA,CAACnB,KAAK,EAAEC,KAAK,KAAK;EAChD,MAAM6D,cAAc,GAAG,IAAInB,GAAG,CAAC,CAAC;EAEhC1C,KAAK,CAACa,OAAO,CAACmB,IAAI,IAAI;IACpB6B,cAAc,CAACR,GAAG,CAACrB,IAAI,CAACC,MAAM,CAAC;IAC/B4B,cAAc,CAACR,GAAG,CAACrB,IAAI,CAACE,MAAM,CAAC;EACjC,CAAC,CAAC;EAEF,MAAM4B,YAAY,GAAG/D,KAAK,CACvBgE,MAAM,CAAC1C,IAAI,IAAI,CAACwC,cAAc,CAACZ,GAAG,CAAC5B,IAAI,CAACG,EAAE,CAAC,CAAC,CAC5CsB,GAAG,CAACzB,IAAI,IAAIA,IAAI,CAACG,EAAE,CAAC;EAEvB,OAAOsC,YAAY;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAM/B,0BAA0B,GAAI/B,KAAK,IAAK;EAC5C,MAAMgE,IAAI,GAAG,IAAItB,GAAG,CAAC,CAAC;EACtB,MAAMuB,UAAU,GAAG,EAAE;EAErBjE,KAAK,CAACa,OAAO,CAACmB,IAAI,IAAI;IACpB,MAAMkC,GAAG,GAAG,GAAGlC,IAAI,CAACC,MAAM,KAAKD,IAAI,CAACE,MAAM,EAAE;IAC5C,IAAI8B,IAAI,CAACf,GAAG,CAACiB,GAAG,CAAC,EAAE;MACjBD,UAAU,CAAC5D,IAAI,CAAC2B,IAAI,CAAC;IACvB,CAAC,MAAM;MACLgC,IAAI,CAACX,GAAG,CAACa,GAAG,CAAC;IACf;EACF,CAAC,CAAC;EAEF,OAAOD,UAAU;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM5B,sBAAsB,GAAGA,CAACtC,KAAK,EAAEC,KAAK,KAAK;EAC/C,MAAMmE,UAAU,GAAGpE,KAAK,CAAC+C,GAAG,CAACvB,CAAC;IAAA,IAAA6C,OAAA;IAAA,QAAAA,OAAA,GAAI7C,CAAC,CAACE,IAAI,cAAA2C,OAAA,uBAANA,OAAA,CAAQxC,SAAS;EAAA,EAAC,CAACmC,MAAM,CAACM,OAAO,CAAC;EACpE,MAAMC,gBAAgB,GAAG,IAAI5B,GAAG,CAACyB,UAAU,CAAC;EAE5C,MAAMI,YAAY,GAAGxE,KAAK,CAACgE,MAAM,CAACxC,CAAC;IAAA,IAAAiD,QAAA;IAAA,QAAAA,QAAA,GAAIjD,CAAC,CAACE,IAAI,cAAA+C,QAAA,uBAANA,QAAA,CAAQC,MAAM;EAAA,EAAC,CAACrE,MAAM;EAC7D,MAAMsE,aAAa,GAAG3E,KAAK,CAACK,MAAM,GAAGmE,YAAY;EAEjD,OAAO;IACLjC,SAAS,EAAEvC,KAAK,CAACK,MAAM;IACvBmC,SAAS,EAAEvC,KAAK,CAACI,MAAM;IACvBkE,gBAAgB,EAAEA,gBAAgB,CAACK,IAAI;IACvCC,iBAAiB,EAAEL,YAAY;IAC/BM,kBAAkB,EAAEH,aAAa;IACjCI,yBAAyB,EAAE/E,KAAK,CAACK,MAAM,GAAG,CAAC,GAAG,CAACJ,KAAK,CAACI,MAAM,GAAGL,KAAK,CAACK,MAAM,EAAE2E,OAAO,CAAC,CAAC,CAAC,GAAG;EAC3F,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,oBAAoB,GAAIC,gBAAgB,IAAK;EACxD,MAAM;IAAEvE,KAAK;IAAET,MAAM;IAAEC;EAAS,CAAC,GAAG+E,gBAAgB;EAEpD,IAAIvE,KAAK,IAAIR,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IAClC,OAAO,oCAAoC;EAC7C,CAAC,MAAM,IAAIM,KAAK,IAAIR,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;IACvC,OAAO,+BAA+BF,QAAQ,CAACE,MAAM,aAAa;EACpE,CAAC,MAAM;IACL,OAAO,kBAAkBH,MAAM,CAACG,MAAM,iBAAiBF,QAAQ,CAACE,MAAM,aAAa;EACrF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM8E,gBAAgB,GAAGA,CAACD,gBAAgB,EAAE1E,QAAQ,KAAK;EAC9D,MAAM;IAAEN,MAAM;IAAEC,QAAQ;IAAEC;EAAK,CAAC,GAAG8E,gBAAgB;EAEnD,QAAQ1E,QAAQ;IACd,KAAKb,kBAAkB,CAACC,KAAK;MAC3B,OAAOM,MAAM;IACf,KAAKP,kBAAkB,CAACE,OAAO;MAC7B,OAAOM,QAAQ;IACjB,KAAKR,kBAAkB,CAACG,IAAI;MAC1B,OAAOM,IAAI;IACb;MACE,OAAO,CAAC,GAAGF,MAAM,EAAE,GAAGC,QAAQ,EAAE,GAAGC,IAAI,CAAC;EAC5C;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}