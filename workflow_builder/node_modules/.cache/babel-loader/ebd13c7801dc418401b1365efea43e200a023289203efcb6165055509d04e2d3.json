{"ast":null,"code":"/**\n * Projects API - Handles project storage using JSON files\n * Connects to Gradio backend for agent execution\n */\n\nconst API_BASE_URL = 'http://localhost:7860';\n\n/**\n * Get all projects from local storage\n */\nexport const getProjects = () => {\n  try {\n    const projects = localStorage.getItem('multi_agent_projects');\n    return projects ? JSON.parse(projects) : [];\n  } catch (error) {\n    console.error('Error loading projects:', error);\n    return [];\n  }\n};\n\n/**\n * Get a single project by ID\n */\nexport const getProject = projectId => {\n  const projects = getProjects();\n  return projects.find(p => p.id === projectId);\n};\n\n/**\n * Create a new project\n */\nexport const createProject = projectData => {\n  const projects = getProjects();\n  const newProject = {\n    id: `project-${Date.now()}`,\n    name: projectData.name,\n    description: projectData.description || '',\n    teams: [],\n    status: 'draft',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    executions: []\n  };\n  projects.push(newProject);\n  localStorage.setItem('multi_agent_projects', JSON.stringify(projects));\n  return newProject;\n};\n\n/**\n * Update an existing project\n */\nexport const updateProject = (projectId, updates) => {\n  const projects = getProjects();\n  const index = projects.findIndex(p => p.id === projectId);\n  if (index === -1) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n  projects[index] = {\n    ...projects[index],\n    ...updates,\n    updatedAt: new Date().toISOString()\n  };\n  localStorage.setItem('multi_agent_projects', JSON.stringify(projects));\n  return projects[index];\n};\n\n/**\n * Delete a project\n */\nexport const deleteProject = projectId => {\n  const projects = getProjects();\n  const filtered = projects.filter(p => p.id !== projectId);\n  localStorage.setItem('multi_agent_projects', JSON.stringify(filtered));\n  return true;\n};\n\n/**\n * Add a team to a project\n */\nexport const addTeam = (projectId, teamData) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n  const newTeam = {\n    id: `team-${Date.now()}`,\n    name: teamData.name,\n    description: teamData.description || '',\n    icon: teamData.icon || 'üë•',\n    color: teamData.color || '#4A90E2',\n    agents: teamData.agents || [],\n    executionOrder: project.teams.length + 1,\n    checkpointEnabled: teamData.checkpointEnabled !== undefined ? teamData.checkpointEnabled : true,\n    createdAt: new Date().toISOString()\n  };\n  project.teams.push(newTeam);\n  return updateProject(projectId, {\n    teams: project.teams\n  });\n};\n\n/**\n * Update a team within a project\n */\nexport const updateTeam = (projectId, teamId, updates) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n  const teamIndex = project.teams.findIndex(t => t.id === teamId);\n  if (teamIndex === -1) {\n    throw new Error(`Team ${teamId} not found`);\n  }\n  project.teams[teamIndex] = {\n    ...project.teams[teamIndex],\n    ...updates\n  };\n  return updateProject(projectId, {\n    teams: project.teams\n  });\n};\n\n/**\n * Delete a team from a project\n */\nexport const deleteTeam = (projectId, teamId) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n  project.teams = project.teams.filter(t => t.id !== teamId);\n  // Reorder remaining teams\n  project.teams.forEach((team, index) => {\n    team.executionOrder = index + 1;\n  });\n  return updateProject(projectId, {\n    teams: project.teams\n  });\n};\n\n/**\n * Reorder teams in a project\n */\nexport const reorderTeams = (projectId, teamIds) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n  const reorderedTeams = teamIds.map((teamId, index) => {\n    const team = project.teams.find(t => t.id === teamId);\n    return {\n      ...team,\n      executionOrder: index + 1\n    };\n  });\n  return updateProject(projectId, {\n    teams: reorderedTeams\n  });\n};\n\n/**\n * Execute a project (run all teams sequentially)\n * Connects to Gradio backend API\n */\nexport const executeProject = async projectId => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n  const execution = {\n    id: `exec-${Date.now()}`,\n    projectId: project.id,\n    status: 'running',\n    startedAt: new Date().toISOString(),\n    teamExecutions: [],\n    totalCost: 0,\n    totalDuration: 0\n  };\n\n  // Update project status\n  updateProject(projectId, {\n    status: 'running',\n    currentExecution: execution.id\n  });\n  try {\n    // Execute teams sequentially\n    for (const team of project.teams.sort((a, b) => a.executionOrder - b.executionOrder)) {\n      const teamExecution = await executeTeam(projectId, team.id, execution.id);\n      execution.teamExecutions.push(teamExecution);\n\n      // If checkpoint enabled, wait for approval\n      if (team.checkpointEnabled && teamExecution.status === 'completed') {\n        // Checkpoint will be handled by UI - pause execution here\n        // Return execution with pending checkpoint\n        execution.status = 'pending_checkpoint';\n        execution.pendingTeamId = team.id;\n        return execution;\n      }\n    }\n\n    // All teams completed\n    execution.status = 'completed';\n    execution.completedAt = new Date().toISOString();\n    execution.totalDuration = execution.teamExecutions.reduce((sum, te) => sum + (te.duration || 0), 0);\n    execution.totalCost = execution.teamExecutions.reduce((sum, te) => sum + (te.cost || 0), 0);\n    updateProject(projectId, {\n      status: 'completed',\n      currentExecution: null\n    });\n\n    // Store execution in project history\n    project.executions.push(execution);\n    updateProject(projectId, {\n      executions: project.executions\n    });\n    return execution;\n  } catch (error) {\n    execution.status = 'failed';\n    execution.error = error.message;\n    execution.completedAt = new Date().toISOString();\n    updateProject(projectId, {\n      status: 'failed',\n      currentExecution: null\n    });\n    throw error;\n  }\n};\n\n/**\n * Execute a single team (calls Gradio backend)\n */\nconst executeTeam = async (projectId, teamId, executionId) => {\n  const project = getProject(projectId);\n  const team = project.teams.find(t => t.id === teamId);\n  if (!team) {\n    throw new Error(`Team ${teamId} not found`);\n  }\n  const teamExecution = {\n    id: `team-exec-${Date.now()}`,\n    teamId: team.id,\n    executionId: executionId,\n    status: 'running',\n    startedAt: new Date().toISOString(),\n    agentOutputs: []\n  };\n  try {\n    // Build prompt with project context\n    const prompt = project.description || \"Execute the following agents\";\n\n    // Get previous team outputs for context\n    const previousOutputs = getPreviousTeamOutputs(project, executionId);\n\n    // Call Gradio API to execute agents\n    const response = await fetch(`${API_BASE_URL}/api/execute-team`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        projectId: project.id,\n        teamId: team.id,\n        agents: team.agents,\n        // Array like ['PM', 'Senior', 'Web']\n        prompt: prompt,\n        previousOutputs: previousOutputs\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || `API error: ${response.statusText}`);\n    }\n    const result = await response.json(); // { executionId, status, message }\n    const apiExecutionId = result.executionId;\n\n    // Poll for completion\n    let attempts = 0;\n    const maxAttempts = 120; // 2 minutes max (1s interval)\n\n    while (attempts < maxAttempts) {\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s\n\n      const statusResponse = await fetch(`${API_BASE_URL}/api/status/${apiExecutionId}`);\n      const status = await statusResponse.json();\n      if (status.status === 'completed') {\n        // Success!\n        teamExecution.status = 'completed';\n        teamExecution.completedAt = new Date().toISOString();\n        teamExecution.agentOutputs = status.outputs || [];\n        teamExecution.duration = status.duration || 0;\n        teamExecution.cost = status.cost || 0;\n        teamExecution.output = status.combinedOutput || '';\n        return teamExecution;\n      } else if (status.status === 'failed') {\n        throw new Error(status.error || 'Execution failed');\n      }\n\n      // Update progress (optional)\n      if (status.progress) {\n        teamExecution.progress = status.progress;\n      }\n      attempts++;\n    }\n    throw new Error('Execution timeout after 2 minutes');\n  } catch (error) {\n    teamExecution.status = 'failed';\n    teamExecution.error = error.message;\n    teamExecution.completedAt = new Date().toISOString();\n    throw error;\n  }\n};\n\n/**\n * Get outputs from previous teams in execution\n */\nconst getPreviousTeamOutputs = (project, executionId) => {\n  // Find execution\n  const execution = project.executions.find(e => e.id === executionId);\n  if (!execution || !execution.teamExecutions) {\n    return [];\n  }\n  return execution.teamExecutions.filter(te => te.status === 'completed').map(te => {\n    var _project$teams$find;\n    return {\n      teamId: te.teamId,\n      teamName: (_project$teams$find = project.teams.find(t => t.id === te.teamId)) === null || _project$teams$find === void 0 ? void 0 : _project$teams$find.name,\n      output: te.output,\n      agentOutputs: te.agentOutputs\n    };\n  });\n};\n\n/**\n * Continue execution after checkpoint approval\n */\nexport const continueExecution = async (projectId, executionId, checkpointAction, editedOutput) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n  const execution = project.executions.find(e => e.id === executionId);\n  if (!execution) {\n    throw new Error(`Execution ${executionId} not found`);\n  }\n\n  // Handle checkpoint action\n  if (checkpointAction === 'deny') {\n    execution.status = 'denied';\n    execution.completedAt = new Date().toISOString();\n    updateProject(projectId, {\n      status: 'denied',\n      currentExecution: null\n    });\n    return execution;\n  }\n  if (checkpointAction === 'edit' && editedOutput) {\n    // Replace last team's output with edited version\n    const lastTeamExecution = execution.teamExecutions[execution.teamExecutions.length - 1];\n    lastTeamExecution.output = editedOutput;\n    lastTeamExecution.edited = true;\n  }\n\n  // Continue with remaining teams\n  execution.status = 'running';\n  const currentTeamIndex = execution.teamExecutions.length;\n  for (let i = currentTeamIndex; i < project.teams.length; i++) {\n    const team = project.teams.sort((a, b) => a.executionOrder - b.executionOrder)[i];\n    const teamExecution = await executeTeam(projectId, team.id, execution.id);\n    execution.teamExecutions.push(teamExecution);\n    if (team.checkpointEnabled && teamExecution.status === 'completed') {\n      execution.status = 'pending_checkpoint';\n      execution.pendingTeamId = team.id;\n      return execution;\n    }\n  }\n\n  // All teams completed\n  execution.status = 'completed';\n  execution.completedAt = new Date().toISOString();\n  updateProject(projectId, {\n    status: 'completed',\n    currentExecution: null\n  });\n  return execution;\n};\n\n/**\n * Get available agent types\n */\nexport const getAvailableAgents = () => {\n  return [{\n    id: 'PM',\n    label: 'Project Manager',\n    icon: 'üìã',\n    color: '#4A90E2'\n  }, {\n    id: 'Memory',\n    label: 'Memory',\n    icon: 'üß†',\n    color: '#9B59B6'\n  }, {\n    id: 'Research',\n    label: 'Research',\n    icon: 'üîç',\n    color: '#E67E22'\n  }, {\n    id: 'Ideas',\n    label: 'Ideas',\n    icon: 'üí°',\n    color: '#F1C40F'\n  }, {\n    id: 'Designs',\n    label: 'Designs',\n    icon: 'üé®',\n    color: '#E91E63'\n  }, {\n    id: 'Senior',\n    label: 'Senior Engineer',\n    icon: 'üë®‚Äçüíª',\n    color: '#3498DB'\n  }, {\n    id: 'iOS',\n    label: 'iOS Developer',\n    icon: 'üì±',\n    color: '#95A5A6'\n  }, {\n    id: 'Android',\n    label: 'Android Developer',\n    icon: 'ü§ñ',\n    color: '#27AE60'\n  }, {\n    id: 'Web',\n    label: 'Web Developer',\n    icon: 'üåê',\n    color: '#16A085'\n  }, {\n    id: 'QA',\n    label: 'QA Engineer',\n    icon: '‚úÖ',\n    color: '#2ECC71'\n  }, {\n    id: 'Verifier',\n    label: 'Verifier',\n    icon: 'üîé',\n    color: '#34495E'\n  }];\n};","map":{"version":3,"names":["API_BASE_URL","getProjects","projects","localStorage","getItem","JSON","parse","error","console","getProject","projectId","find","p","id","createProject","projectData","newProject","Date","now","name","description","teams","status","createdAt","toISOString","updatedAt","executions","push","setItem","stringify","updateProject","updates","index","findIndex","Error","deleteProject","filtered","filter","addTeam","teamData","project","newTeam","icon","color","agents","executionOrder","length","checkpointEnabled","undefined","updateTeam","teamId","teamIndex","t","deleteTeam","forEach","team","reorderTeams","teamIds","reorderedTeams","map","executeProject","execution","startedAt","teamExecutions","totalCost","totalDuration","currentExecution","sort","a","b","teamExecution","executeTeam","pendingTeamId","completedAt","reduce","sum","te","duration","cost","message","executionId","agentOutputs","prompt","previousOutputs","getPreviousTeamOutputs","response","fetch","method","headers","body","ok","json","statusText","result","apiExecutionId","attempts","maxAttempts","Promise","resolve","setTimeout","statusResponse","outputs","output","combinedOutput","progress","e","_project$teams$find","teamName","continueExecution","checkpointAction","editedOutput","lastTeamExecution","edited","currentTeamIndex","i","getAvailableAgents","label"],"sources":["C:/Users/jacob/MultiAgentTeam/workflow_builder/src/api/projectsApi.js"],"sourcesContent":["/**\n * Projects API - Handles project storage using JSON files\n * Connects to Gradio backend for agent execution\n */\n\nconst API_BASE_URL = 'http://localhost:7860';\n\n/**\n * Get all projects from local storage\n */\nexport const getProjects = () => {\n  try {\n    const projects = localStorage.getItem('multi_agent_projects');\n    return projects ? JSON.parse(projects) : [];\n  } catch (error) {\n    console.error('Error loading projects:', error);\n    return [];\n  }\n};\n\n/**\n * Get a single project by ID\n */\nexport const getProject = (projectId) => {\n  const projects = getProjects();\n  return projects.find(p => p.id === projectId);\n};\n\n/**\n * Create a new project\n */\nexport const createProject = (projectData) => {\n  const projects = getProjects();\n  const newProject = {\n    id: `project-${Date.now()}`,\n    name: projectData.name,\n    description: projectData.description || '',\n    teams: [],\n    status: 'draft',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    executions: []\n  };\n\n  projects.push(newProject);\n  localStorage.setItem('multi_agent_projects', JSON.stringify(projects));\n  return newProject;\n};\n\n/**\n * Update an existing project\n */\nexport const updateProject = (projectId, updates) => {\n  const projects = getProjects();\n  const index = projects.findIndex(p => p.id === projectId);\n\n  if (index === -1) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n\n  projects[index] = {\n    ...projects[index],\n    ...updates,\n    updatedAt: new Date().toISOString()\n  };\n\n  localStorage.setItem('multi_agent_projects', JSON.stringify(projects));\n  return projects[index];\n};\n\n/**\n * Delete a project\n */\nexport const deleteProject = (projectId) => {\n  const projects = getProjects();\n  const filtered = projects.filter(p => p.id !== projectId);\n  localStorage.setItem('multi_agent_projects', JSON.stringify(filtered));\n  return true;\n};\n\n/**\n * Add a team to a project\n */\nexport const addTeam = (projectId, teamData) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n\n  const newTeam = {\n    id: `team-${Date.now()}`,\n    name: teamData.name,\n    description: teamData.description || '',\n    icon: teamData.icon || 'üë•',\n    color: teamData.color || '#4A90E2',\n    agents: teamData.agents || [],\n    executionOrder: project.teams.length + 1,\n    checkpointEnabled: teamData.checkpointEnabled !== undefined ? teamData.checkpointEnabled : true,\n    createdAt: new Date().toISOString()\n  };\n\n  project.teams.push(newTeam);\n  return updateProject(projectId, { teams: project.teams });\n};\n\n/**\n * Update a team within a project\n */\nexport const updateTeam = (projectId, teamId, updates) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n\n  const teamIndex = project.teams.findIndex(t => t.id === teamId);\n  if (teamIndex === -1) {\n    throw new Error(`Team ${teamId} not found`);\n  }\n\n  project.teams[teamIndex] = {\n    ...project.teams[teamIndex],\n    ...updates\n  };\n\n  return updateProject(projectId, { teams: project.teams });\n};\n\n/**\n * Delete a team from a project\n */\nexport const deleteTeam = (projectId, teamId) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n\n  project.teams = project.teams.filter(t => t.id !== teamId);\n  // Reorder remaining teams\n  project.teams.forEach((team, index) => {\n    team.executionOrder = index + 1;\n  });\n\n  return updateProject(projectId, { teams: project.teams });\n};\n\n/**\n * Reorder teams in a project\n */\nexport const reorderTeams = (projectId, teamIds) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n\n  const reorderedTeams = teamIds.map((teamId, index) => {\n    const team = project.teams.find(t => t.id === teamId);\n    return {\n      ...team,\n      executionOrder: index + 1\n    };\n  });\n\n  return updateProject(projectId, { teams: reorderedTeams });\n};\n\n/**\n * Execute a project (run all teams sequentially)\n * Connects to Gradio backend API\n */\nexport const executeProject = async (projectId) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n\n  const execution = {\n    id: `exec-${Date.now()}`,\n    projectId: project.id,\n    status: 'running',\n    startedAt: new Date().toISOString(),\n    teamExecutions: [],\n    totalCost: 0,\n    totalDuration: 0\n  };\n\n  // Update project status\n  updateProject(projectId, {\n    status: 'running',\n    currentExecution: execution.id\n  });\n\n  try {\n    // Execute teams sequentially\n    for (const team of project.teams.sort((a, b) => a.executionOrder - b.executionOrder)) {\n      const teamExecution = await executeTeam(projectId, team.id, execution.id);\n      execution.teamExecutions.push(teamExecution);\n\n      // If checkpoint enabled, wait for approval\n      if (team.checkpointEnabled && teamExecution.status === 'completed') {\n        // Checkpoint will be handled by UI - pause execution here\n        // Return execution with pending checkpoint\n        execution.status = 'pending_checkpoint';\n        execution.pendingTeamId = team.id;\n        return execution;\n      }\n    }\n\n    // All teams completed\n    execution.status = 'completed';\n    execution.completedAt = new Date().toISOString();\n    execution.totalDuration = execution.teamExecutions.reduce((sum, te) => sum + (te.duration || 0), 0);\n    execution.totalCost = execution.teamExecutions.reduce((sum, te) => sum + (te.cost || 0), 0);\n\n    updateProject(projectId, {\n      status: 'completed',\n      currentExecution: null\n    });\n\n    // Store execution in project history\n    project.executions.push(execution);\n    updateProject(projectId, { executions: project.executions });\n\n    return execution;\n  } catch (error) {\n    execution.status = 'failed';\n    execution.error = error.message;\n    execution.completedAt = new Date().toISOString();\n\n    updateProject(projectId, {\n      status: 'failed',\n      currentExecution: null\n    });\n\n    throw error;\n  }\n};\n\n/**\n * Execute a single team (calls Gradio backend)\n */\nconst executeTeam = async (projectId, teamId, executionId) => {\n  const project = getProject(projectId);\n  const team = project.teams.find(t => t.id === teamId);\n\n  if (!team) {\n    throw new Error(`Team ${teamId} not found`);\n  }\n\n  const teamExecution = {\n    id: `team-exec-${Date.now()}`,\n    teamId: team.id,\n    executionId: executionId,\n    status: 'running',\n    startedAt: new Date().toISOString(),\n    agentOutputs: []\n  };\n\n  try {\n    // Build prompt with project context\n    const prompt = project.description || \"Execute the following agents\";\n\n    // Get previous team outputs for context\n    const previousOutputs = getPreviousTeamOutputs(project, executionId);\n\n    // Call Gradio API to execute agents\n    const response = await fetch(`${API_BASE_URL}/api/execute-team`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        projectId: project.id,\n        teamId: team.id,\n        agents: team.agents,  // Array like ['PM', 'Senior', 'Web']\n        prompt: prompt,\n        previousOutputs: previousOutputs\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || `API error: ${response.statusText}`);\n    }\n\n    const result = await response.json();  // { executionId, status, message }\n    const apiExecutionId = result.executionId;\n\n    // Poll for completion\n    let attempts = 0;\n    const maxAttempts = 120;  // 2 minutes max (1s interval)\n\n    while (attempts < maxAttempts) {\n      await new Promise(resolve => setTimeout(resolve, 1000));  // Wait 1s\n\n      const statusResponse = await fetch(`${API_BASE_URL}/api/status/${apiExecutionId}`);\n      const status = await statusResponse.json();\n\n      if (status.status === 'completed') {\n        // Success!\n        teamExecution.status = 'completed';\n        teamExecution.completedAt = new Date().toISOString();\n        teamExecution.agentOutputs = status.outputs || [];\n        teamExecution.duration = status.duration || 0;\n        teamExecution.cost = status.cost || 0;\n        teamExecution.output = status.combinedOutput || '';\n        return teamExecution;\n      } else if (status.status === 'failed') {\n        throw new Error(status.error || 'Execution failed');\n      }\n\n      // Update progress (optional)\n      if (status.progress) {\n        teamExecution.progress = status.progress;\n      }\n\n      attempts++;\n    }\n\n    throw new Error('Execution timeout after 2 minutes');\n  } catch (error) {\n    teamExecution.status = 'failed';\n    teamExecution.error = error.message;\n    teamExecution.completedAt = new Date().toISOString();\n    throw error;\n  }\n};\n\n/**\n * Get outputs from previous teams in execution\n */\nconst getPreviousTeamOutputs = (project, executionId) => {\n  // Find execution\n  const execution = project.executions.find(e => e.id === executionId);\n  if (!execution || !execution.teamExecutions) {\n    return [];\n  }\n\n  return execution.teamExecutions\n    .filter(te => te.status === 'completed')\n    .map(te => ({\n      teamId: te.teamId,\n      teamName: project.teams.find(t => t.id === te.teamId)?.name,\n      output: te.output,\n      agentOutputs: te.agentOutputs\n    }));\n};\n\n/**\n * Continue execution after checkpoint approval\n */\nexport const continueExecution = async (projectId, executionId, checkpointAction, editedOutput) => {\n  const project = getProject(projectId);\n  if (!project) {\n    throw new Error(`Project ${projectId} not found`);\n  }\n\n  const execution = project.executions.find(e => e.id === executionId);\n  if (!execution) {\n    throw new Error(`Execution ${executionId} not found`);\n  }\n\n  // Handle checkpoint action\n  if (checkpointAction === 'deny') {\n    execution.status = 'denied';\n    execution.completedAt = new Date().toISOString();\n    updateProject(projectId, { status: 'denied', currentExecution: null });\n    return execution;\n  }\n\n  if (checkpointAction === 'edit' && editedOutput) {\n    // Replace last team's output with edited version\n    const lastTeamExecution = execution.teamExecutions[execution.teamExecutions.length - 1];\n    lastTeamExecution.output = editedOutput;\n    lastTeamExecution.edited = true;\n  }\n\n  // Continue with remaining teams\n  execution.status = 'running';\n  const currentTeamIndex = execution.teamExecutions.length;\n\n  for (let i = currentTeamIndex; i < project.teams.length; i++) {\n    const team = project.teams.sort((a, b) => a.executionOrder - b.executionOrder)[i];\n    const teamExecution = await executeTeam(projectId, team.id, execution.id);\n    execution.teamExecutions.push(teamExecution);\n\n    if (team.checkpointEnabled && teamExecution.status === 'completed') {\n      execution.status = 'pending_checkpoint';\n      execution.pendingTeamId = team.id;\n      return execution;\n    }\n  }\n\n  // All teams completed\n  execution.status = 'completed';\n  execution.completedAt = new Date().toISOString();\n  updateProject(projectId, { status: 'completed', currentExecution: null });\n\n  return execution;\n};\n\n/**\n * Get available agent types\n */\nexport const getAvailableAgents = () => {\n  return [\n    { id: 'PM', label: 'Project Manager', icon: 'üìã', color: '#4A90E2' },\n    { id: 'Memory', label: 'Memory', icon: 'üß†', color: '#9B59B6' },\n    { id: 'Research', label: 'Research', icon: 'üîç', color: '#E67E22' },\n    { id: 'Ideas', label: 'Ideas', icon: 'üí°', color: '#F1C40F' },\n    { id: 'Designs', label: 'Designs', icon: 'üé®', color: '#E91E63' },\n    { id: 'Senior', label: 'Senior Engineer', icon: 'üë®‚Äçüíª', color: '#3498DB' },\n    { id: 'iOS', label: 'iOS Developer', icon: 'üì±', color: '#95A5A6' },\n    { id: 'Android', label: 'Android Developer', icon: 'ü§ñ', color: '#27AE60' },\n    { id: 'Web', label: 'Web Developer', icon: 'üåê', color: '#16A085' },\n    { id: 'QA', label: 'QA Engineer', icon: '‚úÖ', color: '#2ECC71' },\n    { id: 'Verifier', label: 'Verifier', icon: 'üîé', color: '#34495E' }\n  ];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}