{"ast":null,"code":"import yaml from 'js-yaml';\nimport { saveCustomAgent } from './agentLoader';\n\n/**\n * Export workflow to YAML format compatible with existing templates\n */\nexport const exportToYAML = (workflow, agentTypes) => {\n  const {\n    name,\n    nodes,\n    edges\n  } = workflow;\n\n  // Build agent order based on connections\n  const agentOrder = buildExecutionOrder(nodes, edges);\n\n  // Extract agents with their configurations\n  const agents = agentOrder.map(nodeId => {\n    const node = nodes.find(n => n.id === nodeId);\n    return node.data.agentType;\n  });\n\n  // Build custom prompts object\n  const customPrompts = {};\n  nodes.forEach(node => {\n    if (node.data.prompt) {\n      customPrompts[node.data.agentType] = node.data.prompt;\n    }\n  });\n\n  // Build model overrides\n  const modelOverrides = {};\n  nodes.forEach(node => {\n    if (node.data.model !== 'claude-3-5-sonnet-20241022') {\n      modelOverrides[node.data.agentType] = node.data.model;\n    }\n  });\n\n  // Extract custom agents used in workflow\n  const customAgentsMap = new Map();\n  agentOrder.forEach(nodeId => {\n    const node = nodes.find(n => n.id === nodeId);\n    const agentInfo = agentTypes.find(a => a.id === node.data.agentType);\n\n    // If agent is custom and not already added, include it\n    if (agentInfo && agentInfo.custom && !customAgentsMap.has(agentInfo.id)) {\n      customAgentsMap.set(agentInfo.id, {\n        id: agentInfo.id,\n        label: agentInfo.label,\n        icon: agentInfo.icon,\n        color: agentInfo.color,\n        category: agentInfo.category || 'Uncategorized',\n        defaultPrompt: agentInfo.defaultPrompt || ''\n      });\n    }\n  });\n\n  // Create workflow object\n  const workflowObj = {\n    name: name,\n    description: `Workflow with ${nodes.length} agents`,\n    agents: agents,\n    model: 'balanced',\n    // Default model preset\n    code_review_mode: false\n  };\n\n  // Add custom prompts if any\n  if (Object.keys(customPrompts).length > 0) {\n    workflowObj.custom_prompts = customPrompts;\n  }\n\n  // Add model overrides if any\n  if (Object.keys(modelOverrides).length > 0) {\n    workflowObj.model_overrides = modelOverrides;\n  }\n\n  // Add custom agents if any\n  if (customAgentsMap.size > 0) {\n    workflowObj.custom_agents = Array.from(customAgentsMap.values());\n  }\n\n  // Convert to YAML\n  return yaml.dump(workflowObj, {\n    indent: 2,\n    lineWidth: -1,\n    noRefs: true\n  });\n};\n\n/**\n * Import workflow from YAML format\n */\nexport const importFromYAML = (yamlContent, agentTypes) => {\n  try {\n    const workflowObj = yaml.load(yamlContent);\n    const name = workflowObj.name || 'Imported Workflow';\n    const agents = workflowObj.agents || [];\n    const customPrompts = workflowObj.custom_prompts || {};\n    const modelOverrides = workflowObj.model_overrides || {};\n    const customAgentsFromYAML = workflowObj.custom_agents || [];\n\n    // Save custom agents to localStorage if they don't already exist\n    const savedCustomAgentIds = new Set();\n    customAgentsFromYAML.forEach(customAgent => {\n      // Check if custom agent already exists in agentTypes\n      const exists = agentTypes.find(a => a.id === customAgent.id);\n      if (!exists) {\n        // Save to localStorage\n        const success = saveCustomAgent({\n          id: customAgent.id,\n          label: customAgent.label,\n          icon: customAgent.icon,\n          color: customAgent.color,\n          category: customAgent.category || 'Uncategorized',\n          defaultPrompt: customAgent.defaultPrompt || '',\n          custom: true,\n          builtin: false\n        });\n        if (success) {\n          savedCustomAgentIds.add(customAgent.id);\n          console.log(`Imported custom agent: ${customAgent.label}`);\n        }\n      }\n    });\n\n    // Create combined agent lookup (built-in + custom from YAML)\n    const allAgentsForLookup = [...agentTypes, ...customAgentsFromYAML.filter(ca => savedCustomAgentIds.has(ca.id))];\n\n    // Create nodes from agents\n    const nodes = agents.map((agentType, index) => {\n      const agentInfo = allAgentsForLookup.find(a => a.id === agentType);\n      if (!agentInfo) {\n        console.warn(`Unknown agent type: ${agentType}. This agent is not registered in the platform and may not work correctly.`);\n        return null;\n      }\n      return {\n        id: `${agentType}-${Date.now()}-${index}`,\n        type: 'agent',\n        position: {\n          x: 100 + index % 3 * 300,\n          y: 100 + Math.floor(index / 3) * 200\n        },\n        data: {\n          label: agentInfo.label,\n          agentType: agentType,\n          icon: agentInfo.icon,\n          color: agentInfo.color,\n          prompt: customPrompts[agentType] || '',\n          model: modelOverrides[agentType] || 'claude-3-5-sonnet-20241022',\n          custom: agentInfo.custom || false\n        }\n      };\n    }).filter(Boolean);\n\n    // Create edges showing sequential flow\n    const edges = [];\n    for (let i = 0; i < nodes.length - 1; i++) {\n      edges.push({\n        id: `e${i}-${i + 1}`,\n        source: nodes[i].id,\n        target: nodes[i + 1].id,\n        animated: true\n      });\n    }\n    return {\n      name,\n      nodes,\n      edges\n    };\n  } catch (error) {\n    console.error('Error parsing YAML:', error);\n    throw new Error('Invalid YAML format');\n  }\n};\n\n/**\n * Build execution order from nodes and edges using topological sort\n */\nconst buildExecutionOrder = (nodes, edges) => {\n  // Build adjacency list\n  const graph = new Map();\n  const inDegree = new Map();\n\n  // Initialize\n  nodes.forEach(node => {\n    graph.set(node.id, []);\n    inDegree.set(node.id, 0);\n  });\n\n  // Build graph\n  edges.forEach(edge => {\n    graph.get(edge.source).push(edge.target);\n    inDegree.set(edge.target, (inDegree.get(edge.target) || 0) + 1);\n  });\n\n  // Topological sort using Kahn's algorithm\n  const queue = [];\n  const result = [];\n\n  // Find nodes with no incoming edges\n  inDegree.forEach((degree, nodeId) => {\n    if (degree === 0) {\n      queue.push(nodeId);\n    }\n  });\n  while (queue.length > 0) {\n    const nodeId = queue.shift();\n    result.push(nodeId);\n    const neighbors = graph.get(nodeId) || [];\n    neighbors.forEach(neighbor => {\n      inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n      if (inDegree.get(neighbor) === 0) {\n        queue.push(neighbor);\n      }\n    });\n  }\n\n  // If result doesn't contain all nodes, there's a cycle or disconnected nodes\n  // For disconnected nodes, append them at the end\n  if (result.length < nodes.length) {\n    nodes.forEach(node => {\n      if (!result.includes(node.id)) {\n        result.push(node.id);\n      }\n    });\n  }\n  return result;\n};","map":{"version":3,"names":["yaml","saveCustomAgent","exportToYAML","workflow","agentTypes","name","nodes","edges","agentOrder","buildExecutionOrder","agents","map","nodeId","node","find","n","id","data","agentType","customPrompts","forEach","prompt","modelOverrides","model","customAgentsMap","Map","agentInfo","a","custom","has","set","label","icon","color","category","defaultPrompt","workflowObj","description","length","code_review_mode","Object","keys","custom_prompts","model_overrides","size","custom_agents","Array","from","values","dump","indent","lineWidth","noRefs","importFromYAML","yamlContent","load","customAgentsFromYAML","savedCustomAgentIds","Set","customAgent","exists","success","builtin","add","console","log","allAgentsForLookup","filter","ca","index","warn","Date","now","type","position","x","y","Math","floor","Boolean","i","push","source","target","animated","error","Error","graph","inDegree","edge","get","queue","result","degree","shift","neighbors","neighbor","includes"],"sources":["C:/Users/jacob/MultiAgentTeam/workflow_builder/src/utils/yamlConverter.js"],"sourcesContent":["import yaml from 'js-yaml';\nimport { saveCustomAgent } from './agentLoader';\n\n/**\n * Export workflow to YAML format compatible with existing templates\n */\nexport const exportToYAML = (workflow, agentTypes) => {\n  const { name, nodes, edges } = workflow;\n\n  // Build agent order based on connections\n  const agentOrder = buildExecutionOrder(nodes, edges);\n\n  // Extract agents with their configurations\n  const agents = agentOrder.map((nodeId) => {\n    const node = nodes.find((n) => n.id === nodeId);\n    return node.data.agentType;\n  });\n\n  // Build custom prompts object\n  const customPrompts = {};\n  nodes.forEach((node) => {\n    if (node.data.prompt) {\n      customPrompts[node.data.agentType] = node.data.prompt;\n    }\n  });\n\n  // Build model overrides\n  const modelOverrides = {};\n  nodes.forEach((node) => {\n    if (node.data.model !== 'claude-3-5-sonnet-20241022') {\n      modelOverrides[node.data.agentType] = node.data.model;\n    }\n  });\n\n  // Extract custom agents used in workflow\n  const customAgentsMap = new Map();\n  agentOrder.forEach((nodeId) => {\n    const node = nodes.find((n) => n.id === nodeId);\n    const agentInfo = agentTypes.find((a) => a.id === node.data.agentType);\n\n    // If agent is custom and not already added, include it\n    if (agentInfo && agentInfo.custom && !customAgentsMap.has(agentInfo.id)) {\n      customAgentsMap.set(agentInfo.id, {\n        id: agentInfo.id,\n        label: agentInfo.label,\n        icon: agentInfo.icon,\n        color: agentInfo.color,\n        category: agentInfo.category || 'Uncategorized',\n        defaultPrompt: agentInfo.defaultPrompt || '',\n      });\n    }\n  });\n\n  // Create workflow object\n  const workflowObj = {\n    name: name,\n    description: `Workflow with ${nodes.length} agents`,\n    agents: agents,\n    model: 'balanced', // Default model preset\n    code_review_mode: false,\n  };\n\n  // Add custom prompts if any\n  if (Object.keys(customPrompts).length > 0) {\n    workflowObj.custom_prompts = customPrompts;\n  }\n\n  // Add model overrides if any\n  if (Object.keys(modelOverrides).length > 0) {\n    workflowObj.model_overrides = modelOverrides;\n  }\n\n  // Add custom agents if any\n  if (customAgentsMap.size > 0) {\n    workflowObj.custom_agents = Array.from(customAgentsMap.values());\n  }\n\n  // Convert to YAML\n  return yaml.dump(workflowObj, {\n    indent: 2,\n    lineWidth: -1,\n    noRefs: true,\n  });\n};\n\n/**\n * Import workflow from YAML format\n */\nexport const importFromYAML = (yamlContent, agentTypes) => {\n  try {\n    const workflowObj = yaml.load(yamlContent);\n\n    const name = workflowObj.name || 'Imported Workflow';\n    const agents = workflowObj.agents || [];\n    const customPrompts = workflowObj.custom_prompts || {};\n    const modelOverrides = workflowObj.model_overrides || {};\n    const customAgentsFromYAML = workflowObj.custom_agents || [];\n\n    // Save custom agents to localStorage if they don't already exist\n    const savedCustomAgentIds = new Set();\n    customAgentsFromYAML.forEach((customAgent) => {\n      // Check if custom agent already exists in agentTypes\n      const exists = agentTypes.find((a) => a.id === customAgent.id);\n      if (!exists) {\n        // Save to localStorage\n        const success = saveCustomAgent({\n          id: customAgent.id,\n          label: customAgent.label,\n          icon: customAgent.icon,\n          color: customAgent.color,\n          category: customAgent.category || 'Uncategorized',\n          defaultPrompt: customAgent.defaultPrompt || '',\n          custom: true,\n          builtin: false,\n        });\n        if (success) {\n          savedCustomAgentIds.add(customAgent.id);\n          console.log(`Imported custom agent: ${customAgent.label}`);\n        }\n      }\n    });\n\n    // Create combined agent lookup (built-in + custom from YAML)\n    const allAgentsForLookup = [\n      ...agentTypes,\n      ...customAgentsFromYAML.filter((ca) => savedCustomAgentIds.has(ca.id)),\n    ];\n\n    // Create nodes from agents\n    const nodes = agents.map((agentType, index) => {\n      const agentInfo = allAgentsForLookup.find((a) => a.id === agentType);\n      if (!agentInfo) {\n        console.warn(\n          `Unknown agent type: ${agentType}. This agent is not registered in the platform and may not work correctly.`\n        );\n        return null;\n      }\n\n      return {\n        id: `${agentType}-${Date.now()}-${index}`,\n        type: 'agent',\n        position: {\n          x: 100 + (index % 3) * 300,\n          y: 100 + Math.floor(index / 3) * 200,\n        },\n        data: {\n          label: agentInfo.label,\n          agentType: agentType,\n          icon: agentInfo.icon,\n          color: agentInfo.color,\n          prompt: customPrompts[agentType] || '',\n          model: modelOverrides[agentType] || 'claude-3-5-sonnet-20241022',\n          custom: agentInfo.custom || false,\n        },\n      };\n    }).filter(Boolean);\n\n    // Create edges showing sequential flow\n    const edges = [];\n    for (let i = 0; i < nodes.length - 1; i++) {\n      edges.push({\n        id: `e${i}-${i + 1}`,\n        source: nodes[i].id,\n        target: nodes[i + 1].id,\n        animated: true,\n      });\n    }\n\n    return { name, nodes, edges };\n  } catch (error) {\n    console.error('Error parsing YAML:', error);\n    throw new Error('Invalid YAML format');\n  }\n};\n\n/**\n * Build execution order from nodes and edges using topological sort\n */\nconst buildExecutionOrder = (nodes, edges) => {\n  // Build adjacency list\n  const graph = new Map();\n  const inDegree = new Map();\n\n  // Initialize\n  nodes.forEach((node) => {\n    graph.set(node.id, []);\n    inDegree.set(node.id, 0);\n  });\n\n  // Build graph\n  edges.forEach((edge) => {\n    graph.get(edge.source).push(edge.target);\n    inDegree.set(edge.target, (inDegree.get(edge.target) || 0) + 1);\n  });\n\n  // Topological sort using Kahn's algorithm\n  const queue = [];\n  const result = [];\n\n  // Find nodes with no incoming edges\n  inDegree.forEach((degree, nodeId) => {\n    if (degree === 0) {\n      queue.push(nodeId);\n    }\n  });\n\n  while (queue.length > 0) {\n    const nodeId = queue.shift();\n    result.push(nodeId);\n\n    const neighbors = graph.get(nodeId) || [];\n    neighbors.forEach((neighbor) => {\n      inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n      if (inDegree.get(neighbor) === 0) {\n        queue.push(neighbor);\n      }\n    });\n  }\n\n  // If result doesn't contain all nodes, there's a cycle or disconnected nodes\n  // For disconnected nodes, append them at the end\n  if (result.length < nodes.length) {\n    nodes.forEach((node) => {\n      if (!result.includes(node.id)) {\n        result.push(node.id);\n      }\n    });\n  }\n\n  return result;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}