{"ast":null,"code":"/**\n * Execution State Management Utility\n *\n * This utility provides functions to manage and update workflow execution state.\n * In a production environment, this would integrate with WebSocket connections\n * to receive real-time updates from the backend Gradio application.\n */\n\n// Execution state constants\nexport const ExecutionState = {\n  IDLE: 'idle',\n  RUNNING: 'running',\n  COMPLETED: 'completed',\n  FAILED: 'failed'\n};\n\n/**\n * Simulates workflow execution for demonstration purposes.\n * In production, this would be replaced with actual WebSocket/API integration.\n *\n * @param {Array} nodes - Array of workflow nodes\n * @param {Function} updateNodeState - Callback to update node state\n * @param {number} delayPerAgent - Delay in milliseconds between agents (default: 3000)\n */\nexport const simulateWorkflowExecution = async (nodes, updateNodeState, delayPerAgent = 3000) => {\n  // Reset all nodes to idle state\n  nodes.forEach(node => {\n    updateNodeState(node.id, ExecutionState.IDLE);\n  });\n\n  // Execute nodes sequentially\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // Set current node to running\n    updateNodeState(node.id, ExecutionState.RUNNING);\n\n    // Simulate execution time\n    await new Promise(resolve => setTimeout(resolve, delayPerAgent));\n\n    // Set to completed (randomly fail ~10% of the time for demo)\n    const success = Math.random() > 0.1;\n    updateNodeState(node.id, success ? ExecutionState.COMPLETED : ExecutionState.FAILED);\n\n    // If failed, stop execution\n    if (!success) {\n      console.log(`Agent ${node.data.label} failed, stopping execution`);\n      break;\n    }\n  }\n  console.log('Workflow execution complete');\n};\n\n/**\n * Connects to a WebSocket server for real-time execution updates.\n * This would be used in production to receive updates from the Gradio backend.\n *\n * @param {string} websocketUrl - WebSocket server URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @returns {WebSocket} WebSocket instance\n */\nexport const connectToExecutionStream = (websocketUrl, onStateUpdate) => {\n  const ws = new WebSocket(websocketUrl);\n  ws.onopen = () => {\n    console.log('Connected to execution stream');\n  };\n  ws.onmessage = event => {\n    try {\n      const data = JSON.parse(event.data);\n\n      // Expected message format:\n      // {\n      //   type: 'execution_update',\n      //   agentId: 'PM',\n      //   state: 'running' | 'completed' | 'failed',\n      //   timestamp: '2024-01-10T12:00:00Z'\n      // }\n\n      if (data.type === 'execution_update') {\n        onStateUpdate(data.agentId, data.state);\n      }\n    } catch (error) {\n      console.error('Error parsing execution update:', error);\n    }\n  };\n  ws.onerror = error => {\n    console.error('WebSocket error:', error);\n  };\n  ws.onclose = () => {\n    console.log('Disconnected from execution stream');\n  };\n  return ws;\n};\n\n/**\n * HTTP polling alternative for execution state updates.\n * Polls an API endpoint for execution status.\n *\n * @param {string} apiUrl - API endpoint URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @param {number} pollInterval - Poll interval in milliseconds (default: 1000)\n * @returns {Function} Cleanup function to stop polling\n */\nexport const pollExecutionState = (apiUrl, onStateUpdate, pollInterval = 1000) => {\n  let isPolling = true;\n  const poll = async () => {\n    while (isPolling) {\n      try {\n        const response = await fetch(apiUrl);\n        const data = await response.json();\n\n        // Expected response format:\n        // {\n        //   agentStates: {\n        //     'PM': 'completed',\n        //     'Research': 'running',\n        //     'Ideas': 'idle'\n        //   }\n        // }\n\n        if (data.agentStates) {\n          Object.entries(data.agentStates).forEach(([agentId, state]) => {\n            onStateUpdate(agentId, state);\n          });\n        }\n      } catch (error) {\n        console.error('Error polling execution state:', error);\n      }\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\n    }\n  };\n  poll();\n\n  // Return cleanup function\n  return () => {\n    isPolling = false;\n  };\n};","map":{"version":3,"names":["ExecutionState","IDLE","RUNNING","COMPLETED","FAILED","simulateWorkflowExecution","nodes","updateNodeState","delayPerAgent","forEach","node","id","i","length","Promise","resolve","setTimeout","success","Math","random","console","log","data","label","connectToExecutionStream","websocketUrl","onStateUpdate","ws","WebSocket","onopen","onmessage","event","JSON","parse","type","agentId","state","error","onerror","onclose","pollExecutionState","apiUrl","pollInterval","isPolling","poll","response","fetch","json","agentStates","Object","entries"],"sources":["C:/Users/jacob/MultiAgentTeam/workflow_builder/src/utils/executionState.js"],"sourcesContent":["/**\n * Execution State Management Utility\n *\n * This utility provides functions to manage and update workflow execution state.\n * In a production environment, this would integrate with WebSocket connections\n * to receive real-time updates from the backend Gradio application.\n */\n\n// Execution state constants\nexport const ExecutionState = {\n  IDLE: 'idle',\n  RUNNING: 'running',\n  COMPLETED: 'completed',\n  FAILED: 'failed',\n};\n\n/**\n * Simulates workflow execution for demonstration purposes.\n * In production, this would be replaced with actual WebSocket/API integration.\n *\n * @param {Array} nodes - Array of workflow nodes\n * @param {Function} updateNodeState - Callback to update node state\n * @param {number} delayPerAgent - Delay in milliseconds between agents (default: 3000)\n */\nexport const simulateWorkflowExecution = async (nodes, updateNodeState, delayPerAgent = 3000) => {\n  // Reset all nodes to idle state\n  nodes.forEach(node => {\n    updateNodeState(node.id, ExecutionState.IDLE);\n  });\n\n  // Execute nodes sequentially\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // Set current node to running\n    updateNodeState(node.id, ExecutionState.RUNNING);\n\n    // Simulate execution time\n    await new Promise(resolve => setTimeout(resolve, delayPerAgent));\n\n    // Set to completed (randomly fail ~10% of the time for demo)\n    const success = Math.random() > 0.1;\n    updateNodeState(node.id, success ? ExecutionState.COMPLETED : ExecutionState.FAILED);\n\n    // If failed, stop execution\n    if (!success) {\n      console.log(`Agent ${node.data.label} failed, stopping execution`);\n      break;\n    }\n  }\n\n  console.log('Workflow execution complete');\n};\n\n/**\n * Connects to a WebSocket server for real-time execution updates.\n * This would be used in production to receive updates from the Gradio backend.\n *\n * @param {string} websocketUrl - WebSocket server URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @returns {WebSocket} WebSocket instance\n */\nexport const connectToExecutionStream = (websocketUrl, onStateUpdate) => {\n  const ws = new WebSocket(websocketUrl);\n\n  ws.onopen = () => {\n    console.log('Connected to execution stream');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n\n      // Expected message format:\n      // {\n      //   type: 'execution_update',\n      //   agentId: 'PM',\n      //   state: 'running' | 'completed' | 'failed',\n      //   timestamp: '2024-01-10T12:00:00Z'\n      // }\n\n      if (data.type === 'execution_update') {\n        onStateUpdate(data.agentId, data.state);\n      }\n    } catch (error) {\n      console.error('Error parsing execution update:', error);\n    }\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('Disconnected from execution stream');\n  };\n\n  return ws;\n};\n\n/**\n * HTTP polling alternative for execution state updates.\n * Polls an API endpoint for execution status.\n *\n * @param {string} apiUrl - API endpoint URL\n * @param {Function} onStateUpdate - Callback when state update received\n * @param {number} pollInterval - Poll interval in milliseconds (default: 1000)\n * @returns {Function} Cleanup function to stop polling\n */\nexport const pollExecutionState = (apiUrl, onStateUpdate, pollInterval = 1000) => {\n  let isPolling = true;\n\n  const poll = async () => {\n    while (isPolling) {\n      try {\n        const response = await fetch(apiUrl);\n        const data = await response.json();\n\n        // Expected response format:\n        // {\n        //   agentStates: {\n        //     'PM': 'completed',\n        //     'Research': 'running',\n        //     'Ideas': 'idle'\n        //   }\n        // }\n\n        if (data.agentStates) {\n          Object.entries(data.agentStates).forEach(([agentId, state]) => {\n            onStateUpdate(agentId, state);\n          });\n        }\n      } catch (error) {\n        console.error('Error polling execution state:', error);\n      }\n\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\n    }\n  };\n\n  poll();\n\n  // Return cleanup function\n  return () => {\n    isPolling = false;\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}